#!/usr/bin/perl
#
# Copyright 2000 Daniel Klein, dvk@lonewolf.com - Unlimited distribution and
# use permitted as long as this copyright notice is included in all copies.
#
use strict;
use Getopt::Std;

use vars qw($first $last $count $tally $opt_n $opt_a
	    $from $to $domain
	    %from %to %from_user %to_user 
	    );

getopts('an:')	|| die "Usage: $0 [-a] [-n topN] [sendmail-logfile ...]\n";

##
# smto - Processes message entries from sendmail logfile and report on top N
# mail users (default == top10).
#
# This program will read /var/log/maillog by default, but you can also give
# it a list of files (including gzipped files) as arguments, and it will
# summarize all of them.
#
# Mail log lines for delivered messages look like this:
#
# Feb 15 03:17:35 cub sendmail[21863]: DAA21863: from=<root@cow.ibp.com>, size=522, class=0, pri=30522, nrcpts=1, msgid=<200002150817.DAA06993@cow.ibp.com>, proto=ESMTP, relay=root@cow.ibp.com [206.181.94.67]
# Feb 15 03:17:35 cub sendmail[21867]: DAA21863: to=<dvk@lonewolf.com>, delay=00:00:01, xdelay=00:00:00, mailer=esmtp, relay=howl.lonewolf.com. [206.181.95.161], stat=Sent (DAA25733 Message accepted for delivery)
#
##

@ARGV = ("/var/log/maillog")	unless @ARGV;
$opt_n ||= 10;			# Default to top 10

for (@ARGV) {
    if (/\.gz$/) {
	open(INPUT, "zcat $_ |") || die "Can't open $_ - $!";
	}
    else {
	open(INPUT, "$_") || die "Can't open $_ - $!";
	}
    while (<INPUT>) {
	$first = $_ unless $first;
	$last = $_;
	if (($from) = /\bfrom=<?(.*?)>?,/) {
	    ($domain) = ($from = lc($from)) =~ /@(.*)/;
	    $from{$domain}->{$from}++;
	    $from{$domain}->{Total}++;
	    $from_user{$from}++;
	    }
	elsif (($to) = /\bto=<?(.*?)>?,.*stat=Sent/) {
	    ($domain) = ($to = lc($to)) =~ /@(.*)/;
	    $to{$domain}->{$to}++;
	    $to{$domain}->{Total}++;
	    $to_user{$to}++;
	    }
	else {
	    next;
	    }
	$tally++;
	}
    close INPUT;
    }

$from = $1 if $first =~ /^(.{7}\d\d:\d\d:\d\d )/;
$to = $1 if $last =~ /^(.{7}\d\d:\d\d:\d\d )/;
print "\nSendmail Messages for $from - $to\n";
print "-----------------------------------------------------------------\n";
print "$tally messages processed\n";

print "\nTop $opt_n from addresses:\n";
$count = 0;
for my $user (sort
	{$from_user{$b} <=> $from_user{$a} || $a cmp $b} keys %from_user) {
    printf "\t%4d %s\n", $from_user{$user}, $user;
    last if ++$count == $opt_n;
    }
print "\nTop $opt_n to addresses:\n";
$count = 0;
for my $user (sort
	{$to_user{$b} <=> $to_user{$a} || $a cmp $b} keys %to_user) {
    printf "\t%4d %s\n", $to_user{$user}, $user;
    last if ++$count == $opt_n;
    }

exit unless $opt_a;		# Quit unless we want a full report

print "\nMessages from:\n";
for my $domain (sort
	{$from{$b}->{Total} <=> $from{$a}->{Total} || $a cmp $b} keys %from) {
    printf "\t%4d %s\n", $from{$domain}->{Total}, $domain;
    for my $user (sort
	    {$from{$domain}->{$b} <=> $from{$domain}->{$a} ||
		$a cmp $b} keys %{$from{$domain}}) {
	next if $user eq "Total";
	printf "\t\t%4d %s\n", $from{$domain}->{$user}, $user;
	}
    }
print "\nMessages to:\n";
for my $domain (sort
	{$to{$b}->{Total} <=> $to{$a}->{Total} || $a cmp $b} keys %to) {
    printf "\t%4d %s\n", $to{$domain}->{Total}, $domain;
    for my $user (sort
	    {$to{$domain}->{$b} <=> $to{$domain}->{$a} ||
		$a cmp $b} keys %{$to{$domain}}) {
	next if $user eq "Total";
	printf "\t\t%4d %s\n", $to{$domain}->{$user}, $user;
	}
    }
